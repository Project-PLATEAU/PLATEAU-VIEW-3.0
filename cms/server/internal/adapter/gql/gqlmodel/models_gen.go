// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlmodel

import (
	"fmt"
	"io"
	"net/url"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/reearth/reearthx/usecasex"
	"golang.org/x/text/language"
)

type Condition interface {
	IsCondition()
}

type Node interface {
	IsNode()
	GetID() ID
}

type Operator interface {
	IsOperator()
}

type Resource interface {
	IsResource()
}

type SchemaFieldTypeProperty interface {
	IsSchemaFieldTypeProperty()
}

type WorkspaceMember interface {
	IsWorkspaceMember()
}

type AddCommentInput struct {
	ThreadID ID     `json:"threadId"`
	Content  string `json:"content"`
}

type AddIntegrationToWorkspaceInput struct {
	WorkspaceID   ID   `json:"workspaceId"`
	IntegrationID ID   `json:"integrationId"`
	Role          Role `json:"role"`
}

type AddUsersToWorkspaceInput struct {
	WorkspaceID ID             `json:"workspaceId"`
	Users       []*MemberInput `json:"users"`
}

type AddUsersToWorkspacePayload struct {
	Workspace *Workspace `json:"workspace"`
}

type AndCondition struct {
	Conditions []Condition `json:"conditions"`
}

func (AndCondition) IsCondition() {}

type AndConditionInput struct {
	Conditions []*ConditionInput `json:"conditions"`
}

type ApproveRequestInput struct {
	RequestID ID `json:"requestId"`
}

type Asset struct {
	ID                      ID                       `json:"id"`
	Project                 *Project                 `json:"project"`
	ProjectID               ID                       `json:"projectId"`
	CreatedAt               time.Time                `json:"createdAt"`
	CreatedBy               Operator                 `json:"createdBy"`
	CreatedByType           OperatorType             `json:"createdByType"`
	CreatedByID             ID                       `json:"createdById"`
	Items                   []*AssetItem             `json:"items,omitempty"`
	Size                    int64                    `json:"size"`
	PreviewType             *PreviewType             `json:"previewType,omitempty"`
	UUID                    string                   `json:"uuid"`
	Thread                  *Thread                  `json:"thread,omitempty"`
	ThreadID                ID                       `json:"threadId"`
	URL                     string                   `json:"url"`
	FileName                string                   `json:"fileName"`
	ArchiveExtractionStatus *ArchiveExtractionStatus `json:"archiveExtractionStatus,omitempty"`
}

func (Asset) IsNode()        {}
func (this Asset) GetID() ID { return this.ID }

type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	Nodes      []*Asset     `json:"nodes"`
	PageInfo   *PageInfo    `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

type AssetEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *Asset          `json:"node,omitempty"`
}

type AssetFile struct {
	Name        string   `json:"name"`
	Size        int64    `json:"size"`
	ContentType *string  `json:"contentType,omitempty"`
	Path        string   `json:"path"`
	FilePaths   []string `json:"filePaths,omitempty"`
}

type AssetItem struct {
	ItemID  ID `json:"itemId"`
	ModelID ID `json:"modelId"`
}

type AssetSort struct {
	SortBy    AssetSortType  `json:"sortBy"`
	Direction *SortDirection `json:"direction,omitempty"`
}

type BasicFieldCondition struct {
	FieldID  *FieldSelector `json:"fieldId"`
	Operator BasicOperator  `json:"operator"`
	Value    interface{}    `json:"value"`
}

func (BasicFieldCondition) IsCondition() {}

type BasicFieldConditionInput struct {
	FieldID  *FieldSelectorInput `json:"fieldId"`
	Operator BasicOperator       `json:"operator"`
	Value    interface{}         `json:"value"`
}

type BoolFieldCondition struct {
	FieldID  *FieldSelector `json:"fieldId"`
	Operator BoolOperator   `json:"operator"`
	Value    bool           `json:"value"`
}

func (BoolFieldCondition) IsCondition() {}

type BoolFieldConditionInput struct {
	FieldID  *FieldSelectorInput `json:"fieldId"`
	Operator BoolOperator        `json:"operator"`
	Value    bool                `json:"value"`
}

type CesiumResourceProps struct {
	Name                 string `json:"name"`
	URL                  string `json:"url"`
	Image                string `json:"image"`
	CesiumIonAssetID     string `json:"cesiumIonAssetId"`
	CesiumIonAccessToken string `json:"cesiumIonAccessToken"`
}

type CesiumResourcePropsInput struct {
	Name                 string `json:"name"`
	URL                  string `json:"url"`
	Image                string `json:"image"`
	CesiumIonAssetID     string `json:"cesiumIonAssetId"`
	CesiumIonAccessToken string `json:"cesiumIonAccessToken"`
}

type Column struct {
	Field   *FieldSelector `json:"field"`
	Visible bool           `json:"visible"`
}

type ColumnSelectionInput struct {
	Field   *FieldSelectorInput `json:"field"`
	Visible bool                `json:"visible"`
}

type Comment struct {
	ID          ID           `json:"id"`
	ThreadID    ID           `json:"threadId"`
	WorkspaceID ID           `json:"workspaceId"`
	Author      Operator     `json:"author,omitempty"`
	AuthorType  OperatorType `json:"authorType"`
	AuthorID    ID           `json:"authorId"`
	Content     string       `json:"content"`
	CreatedAt   time.Time    `json:"createdAt"`
}

type CommentPayload struct {
	Thread  *Thread  `json:"thread"`
	Comment *Comment `json:"comment"`
}

type ConditionInput struct {
	And      *AndConditionInput           `json:"and,omitempty"`
	Or       *OrConditionInput            `json:"or,omitempty"`
	Basic    *BasicFieldConditionInput    `json:"basic,omitempty"`
	Nullable *NullableFieldConditionInput `json:"nullable,omitempty"`
	Multiple *MultipleFieldConditionInput `json:"multiple,omitempty"`
	Bool     *BoolFieldConditionInput     `json:"bool,omitempty"`
	String   *StringFieldConditionInput   `json:"string,omitempty"`
	Number   *NumberFieldConditionInput   `json:"number,omitempty"`
	Time     *TimeFieldConditionInput     `json:"time,omitempty"`
}

type CorrespondingFieldInput struct {
	FieldID     *ID    `json:"fieldId,omitempty"`
	Title       string `json:"title"`
	Key         string `json:"key"`
	Description string `json:"description"`
	Required    bool   `json:"required"`
}

type CreateAssetInput struct {
	ProjectID         ID              `json:"projectId"`
	File              *graphql.Upload `json:"file,omitempty"`
	URL               *string         `json:"url,omitempty"`
	Token             *string         `json:"token,omitempty"`
	SkipDecompression *bool           `json:"skipDecompression,omitempty"`
}

type CreateAssetPayload struct {
	Asset *Asset `json:"asset"`
}

type CreateAssetUploadInput struct {
	ProjectID     ID      `json:"projectId"`
	Filename      *string `json:"filename,omitempty"`
	ContentLength *int    `json:"contentLength,omitempty"`
	Cursor        *string `json:"cursor,omitempty"`
}

type CreateAssetUploadPayload struct {
	Token         string  `json:"token"`
	URL           string  `json:"url"`
	ContentType   *string `json:"contentType,omitempty"`
	ContentLength int     `json:"contentLength"`
	Next          *string `json:"next,omitempty"`
}

type CreateFieldInput struct {
	ModelID      *ID                           `json:"modelId,omitempty"`
	GroupID      *ID                           `json:"groupId,omitempty"`
	Type         SchemaFieldType               `json:"type"`
	Title        string                        `json:"title"`
	Metadata     *bool                         `json:"metadata,omitempty"`
	Description  *string                       `json:"description,omitempty"`
	Key          string                        `json:"key"`
	Multiple     bool                          `json:"multiple"`
	Unique       bool                          `json:"unique"`
	Required     bool                          `json:"required"`
	IsTitle      bool                          `json:"isTitle"`
	TypeProperty *SchemaFieldTypePropertyInput `json:"typeProperty"`
}

type CreateGroupInput struct {
	ProjectID   ID      `json:"projectId"`
	Name        string  `json:"name"`
	Key         string  `json:"key"`
	Description *string `json:"description,omitempty"`
}

type CreateIntegrationInput struct {
	Name        string          `json:"name"`
	Description *string         `json:"description,omitempty"`
	LogoURL     url.URL         `json:"logoUrl"`
	Type        IntegrationType `json:"type"`
}

type CreateItemInput struct {
	SchemaID   ID                `json:"schemaId"`
	ModelID    ID                `json:"modelId"`
	MetadataID *ID               `json:"metadataId,omitempty"`
	OriginalID *ID               `json:"originalId,omitempty"`
	Fields     []*ItemFieldInput `json:"fields"`
}

type CreateModelInput struct {
	ProjectID   ID      `json:"projectId"`
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	Key         *string `json:"key,omitempty"`
}

type CreateProjectInput struct {
	WorkspaceID  ID      `json:"workspaceId"`
	Name         *string `json:"name,omitempty"`
	Description  *string `json:"description,omitempty"`
	Alias        *string `json:"alias,omitempty"`
	RequestRoles []Role  `json:"requestRoles,omitempty"`
}

type CreateRequestInput struct {
	ProjectID   ID                  `json:"projectId"`
	Title       string              `json:"title"`
	Description *string             `json:"description,omitempty"`
	State       *RequestState       `json:"state,omitempty"`
	ReviewersID []ID                `json:"reviewersId,omitempty"`
	Items       []*RequestItemInput `json:"items"`
}

type CreateThreadInput struct {
	WorkspaceID ID `json:"workspaceId"`
}

type CreateViewInput struct {
	Name      string                  `json:"name"`
	ModelID   ID                      `json:"modelId"`
	ProjectID ID                      `json:"projectId"`
	Sort      *ItemSortInput          `json:"sort,omitempty"`
	Filter    *ConditionInput         `json:"filter,omitempty"`
	Columns   []*ColumnSelectionInput `json:"columns,omitempty"`
}

type CreateWebhookInput struct {
	IntegrationID ID                   `json:"integrationId"`
	Name          string               `json:"name"`
	URL           url.URL              `json:"url"`
	Active        bool                 `json:"active"`
	Trigger       *WebhookTriggerInput `json:"trigger"`
	Secret        string               `json:"secret"`
}

type CreateWorkspaceInput struct {
	Name string `json:"name"`
}

type CreateWorkspacePayload struct {
	Workspace *Workspace `json:"workspace"`
}

type DecompressAssetInput struct {
	AssetID ID `json:"assetId"`
}

type DecompressAssetPayload struct {
	Asset *Asset `json:"asset"`
}

type DeleteAssetInput struct {
	AssetID ID `json:"assetId"`
}

type DeleteAssetPayload struct {
	AssetID ID `json:"assetId"`
}

type DeleteCommentInput struct {
	ThreadID  ID `json:"threadId"`
	CommentID ID `json:"commentId"`
}

type DeleteCommentPayload struct {
	Thread    *Thread `json:"thread"`
	CommentID ID      `json:"commentId"`
}

type DeleteFieldInput struct {
	ModelID  *ID   `json:"modelId,omitempty"`
	GroupID  *ID   `json:"groupId,omitempty"`
	FieldID  ID    `json:"fieldId"`
	Metadata *bool `json:"metadata,omitempty"`
}

type DeleteFieldPayload struct {
	FieldID ID `json:"fieldId"`
}

type DeleteGroupInput struct {
	GroupID ID `json:"groupId"`
}

type DeleteGroupPayload struct {
	GroupID ID `json:"groupId"`
}

type DeleteIntegrationInput struct {
	IntegrationID ID `json:"integrationId"`
}

type DeleteIntegrationPayload struct {
	IntegrationID ID `json:"integrationId"`
}

type DeleteItemInput struct {
	ItemID ID `json:"itemId"`
}

type DeleteItemPayload struct {
	ItemID ID `json:"itemId"`
}

type DeleteMeInput struct {
	UserID ID `json:"userId"`
}

type DeleteMePayload struct {
	UserID ID `json:"userId"`
}

type DeleteModelInput struct {
	ModelID ID `json:"modelId"`
}

type DeleteModelPayload struct {
	ModelID ID `json:"modelId"`
}

type DeleteProjectInput struct {
	ProjectID ID `json:"projectId"`
}

type DeleteProjectPayload struct {
	ProjectID ID `json:"projectId"`
}

type DeleteRequestInput struct {
	ProjectID  ID   `json:"projectId"`
	RequestsID []ID `json:"requestsId"`
}

type DeleteRequestPayload struct {
	Requests []ID `json:"requests"`
}

type DeleteViewInput struct {
	ViewID ID `json:"viewId"`
}

type DeleteViewPayload struct {
	ViewID ID `json:"viewId"`
}

type DeleteWebhookInput struct {
	IntegrationID ID `json:"integrationId"`
	WebhookID     ID `json:"webhookId"`
}

type DeleteWebhookPayload struct {
	WebhookID ID `json:"webhookId"`
}

type DeleteWorkspaceInput struct {
	WorkspaceID ID `json:"workspaceId"`
}

type DeleteWorkspacePayload struct {
	WorkspaceID ID `json:"workspaceId"`
}

type FieldPayload struct {
	Field *SchemaField `json:"field"`
}

type FieldSelector struct {
	Type FieldType `json:"type"`
	ID   *ID       `json:"id,omitempty"`
}

type FieldSelectorInput struct {
	ID   *ID       `json:"id,omitempty"`
	Type FieldType `json:"type"`
}

type FieldsPayload struct {
	Fields []*SchemaField `json:"fields"`
}

type Group struct {
	ID          ID             `json:"id"`
	SchemaID    ID             `json:"schemaId"`
	ProjectID   ID             `json:"projectId"`
	Name        string         `json:"name"`
	Description string         `json:"description"`
	Key         string         `json:"key"`
	Schema      *Schema        `json:"schema"`
	Project     *Project       `json:"project"`
	Fields      []*SchemaField `json:"fields"`
}

func (Group) IsNode()        {}
func (this Group) GetID() ID { return this.ID }

type GroupPayload struct {
	Group *Group `json:"group"`
}

type Integration struct {
	ID          ID                 `json:"id"`
	Name        string             `json:"name"`
	Description *string            `json:"description,omitempty"`
	LogoURL     url.URL            `json:"logoUrl"`
	IType       IntegrationType    `json:"iType"`
	DeveloperID ID                 `json:"developerId"`
	Developer   *User              `json:"developer"`
	Config      *IntegrationConfig `json:"config,omitempty"`
	CreatedAt   time.Time          `json:"createdAt"`
	UpdatedAt   time.Time          `json:"updatedAt"`
}

func (Integration) IsOperator() {}

func (Integration) IsNode()        {}
func (this Integration) GetID() ID { return this.ID }

type IntegrationConfig struct {
	Token    string     `json:"token"`
	Webhooks []*Webhook `json:"webhooks"`
}

type IntegrationPayload struct {
	Integration *Integration `json:"integration"`
}

type Item struct {
	ID                     ID           `json:"id"`
	SchemaID               ID           `json:"schemaId"`
	ThreadID               ID           `json:"threadId"`
	ModelID                ID           `json:"modelId"`
	ProjectID              ID           `json:"projectId"`
	IntegrationID          *ID          `json:"integrationId,omitempty"`
	UpdatedByUserID        *ID          `json:"updatedByUserId,omitempty"`
	UpdatedByIntegrationID *ID          `json:"updatedByIntegrationId,omitempty"`
	UserID                 *ID          `json:"userId,omitempty"`
	MetadataID             *ID          `json:"metadataId,omitempty"`
	IsMetadata             bool         `json:"isMetadata"`
	OriginalID             *ID          `json:"originalId,omitempty"`
	CreatedBy              Operator     `json:"createdBy,omitempty"`
	Schema                 *Schema      `json:"schema"`
	Model                  *Model       `json:"model"`
	Status                 ItemStatus   `json:"status"`
	Project                *Project     `json:"project"`
	Thread                 *Thread      `json:"thread"`
	Fields                 []*ItemField `json:"fields"`
	Assets                 []*Asset     `json:"assets"`
	ReferencedItems        []*Item      `json:"referencedItems,omitempty"`
	CreatedAt              time.Time    `json:"createdAt"`
	UpdatedAt              time.Time    `json:"updatedAt"`
	UpdatedBy              Operator     `json:"updatedBy,omitempty"`
	Version                string       `json:"version"`
	Metadata               *Item        `json:"metadata,omitempty"`
	Original               *Item        `json:"original,omitempty"`
	Title                  *string      `json:"title,omitempty"`
}

func (Item) IsNode()        {}
func (this Item) GetID() ID { return this.ID }

type ItemConnection struct {
	Edges      []*ItemEdge `json:"edges"`
	Nodes      []*Item     `json:"nodes"`
	PageInfo   *PageInfo   `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

type ItemEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *Item           `json:"node,omitempty"`
}

type ItemField struct {
	SchemaFieldID ID              `json:"schemaFieldId"`
	ItemGroupID   *ID             `json:"itemGroupId,omitempty"`
	Type          SchemaFieldType `json:"type"`
	Value         interface{}     `json:"value,omitempty"`
}

type ItemFieldInput struct {
	SchemaFieldID ID              `json:"schemaFieldId"`
	ItemGroupID   *ID             `json:"itemGroupId,omitempty"`
	Type          SchemaFieldType `json:"type"`
	Value         interface{}     `json:"value"`
}

type ItemPayload struct {
	Item *Item `json:"item"`
}

type ItemQueryInput struct {
	Project ID      `json:"project"`
	Model   ID      `json:"model"`
	Schema  *ID     `json:"schema,omitempty"`
	Q       *string `json:"q,omitempty"`
}

type ItemSort struct {
	Field     *FieldSelector `json:"field"`
	Direction *SortDirection `json:"direction,omitempty"`
}

type ItemSortInput struct {
	Field     *FieldSelectorInput `json:"field"`
	Direction *SortDirection      `json:"direction,omitempty"`
}

type KeyAvailability struct {
	Key       string `json:"key"`
	Available bool   `json:"available"`
}

type Me struct {
	ID            ID             `json:"id"`
	Name          string         `json:"name"`
	Email         string         `json:"email"`
	Lang          language.Tag   `json:"lang"`
	Theme         Theme          `json:"theme"`
	Host          *string        `json:"host,omitempty"`
	MyWorkspaceID ID             `json:"myWorkspaceId"`
	Auths         []string       `json:"auths"`
	Workspaces    []*Workspace   `json:"workspaces"`
	MyWorkspace   *Workspace     `json:"myWorkspace,omitempty"`
	Integrations  []*Integration `json:"integrations"`
}

type MemberInput struct {
	UserID ID   `json:"userId"`
	Role   Role `json:"role"`
}

type Model struct {
	ID               ID        `json:"id"`
	ProjectID        ID        `json:"projectId"`
	SchemaID         ID        `json:"schemaId"`
	MetadataSchemaID *ID       `json:"metadataSchemaId,omitempty"`
	Name             string    `json:"name"`
	Description      string    `json:"description"`
	Key              string    `json:"key"`
	Project          *Project  `json:"project"`
	Schema           *Schema   `json:"schema"`
	MetadataSchema   *Schema   `json:"metadataSchema,omitempty"`
	Public           bool      `json:"public"`
	CreatedAt        time.Time `json:"createdAt"`
	UpdatedAt        time.Time `json:"updatedAt"`
	Order            *int      `json:"order,omitempty"`
}

func (Model) IsNode()        {}
func (this Model) GetID() ID { return this.ID }

type ModelConnection struct {
	Edges      []*ModelEdge `json:"edges"`
	Nodes      []*Model     `json:"nodes"`
	PageInfo   *PageInfo    `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

type ModelEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *Model          `json:"node,omitempty"`
}

type ModelPayload struct {
	Model *Model `json:"model"`
}

type ModelsPayload struct {
	Models []*Model `json:"models"`
}

type MultipleFieldCondition struct {
	FieldID  *FieldSelector   `json:"fieldId"`
	Operator MultipleOperator `json:"operator"`
	Value    []interface{}    `json:"value"`
}

func (MultipleFieldCondition) IsCondition() {}

type MultipleFieldConditionInput struct {
	FieldID  *FieldSelectorInput `json:"fieldId"`
	Operator MultipleOperator    `json:"operator"`
	Value    []interface{}       `json:"value"`
}

type Mutation struct {
}

type NullableFieldCondition struct {
	FieldID  *FieldSelector   `json:"fieldId"`
	Operator NullableOperator `json:"operator"`
}

func (NullableFieldCondition) IsCondition() {}

type NullableFieldConditionInput struct {
	FieldID  *FieldSelectorInput `json:"fieldId"`
	Operator NullableOperator    `json:"operator"`
}

type NumberFieldCondition struct {
	FieldID  *FieldSelector `json:"fieldId"`
	Operator NumberOperator `json:"operator"`
	Value    float64        `json:"value"`
}

func (NumberFieldCondition) IsCondition() {}

type NumberFieldConditionInput struct {
	FieldID  *FieldSelectorInput `json:"fieldId"`
	Operator NumberOperator      `json:"operator"`
	Value    float64             `json:"value"`
}

type OperatorInput struct {
	Basic    *BasicOperator    `json:"basic,omitempty"`
	Nullable *NullableOperator `json:"nullable,omitempty"`
	Bool     *BoolOperator     `json:"bool,omitempty"`
	String   *StringOperator   `json:"string,omitempty"`
	Number   *NumberOperator   `json:"number,omitempty"`
	Time     *TimeOperator     `json:"time,omitempty"`
}

type OrCondition struct {
	Conditions []Condition `json:"conditions"`
}

func (OrCondition) IsCondition() {}

type OrConditionInput struct {
	Conditions []*ConditionInput `json:"conditions"`
}

type PageInfo struct {
	StartCursor     *usecasex.Cursor `json:"startCursor,omitempty"`
	EndCursor       *usecasex.Cursor `json:"endCursor,omitempty"`
	HasNextPage     bool             `json:"hasNextPage"`
	HasPreviousPage bool             `json:"hasPreviousPage"`
}

type Pagination struct {
	First  *int             `json:"first,omitempty"`
	Last   *int             `json:"last,omitempty"`
	Offset *int             `json:"offset,omitempty"`
	After  *usecasex.Cursor `json:"after,omitempty"`
	Before *usecasex.Cursor `json:"before,omitempty"`
}

type Project struct {
	ID           ID                  `json:"id"`
	Name         string              `json:"name"`
	Description  string              `json:"description"`
	Alias        string              `json:"alias"`
	WorkspaceID  ID                  `json:"workspaceId"`
	Workspace    *Workspace          `json:"workspace,omitempty"`
	CreatedAt    time.Time           `json:"createdAt"`
	UpdatedAt    time.Time           `json:"updatedAt"`
	Publication  *ProjectPublication `json:"publication,omitempty"`
	RequestRoles []Role              `json:"requestRoles,omitempty"`
}

func (Project) IsNode()        {}
func (this Project) GetID() ID { return this.ID }

type ProjectAliasAvailability struct {
	Alias     string `json:"alias"`
	Available bool   `json:"available"`
}

type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	Nodes      []*Project     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type ProjectEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *Project        `json:"node,omitempty"`
}

type ProjectPayload struct {
	Project *Project `json:"project"`
}

type ProjectPublication struct {
	Scope       ProjectPublicationScope `json:"scope"`
	AssetPublic bool                    `json:"assetPublic"`
}

type PublishItemInput struct {
	ItemIds []ID `json:"itemIds"`
}

type PublishItemPayload struct {
	Items []*Item `json:"items"`
}

type PublishModelInput struct {
	ModelID ID   `json:"modelId"`
	Status  bool `json:"status"`
}

type PublishModelPayload struct {
	ModelID ID   `json:"modelId"`
	Status  bool `json:"status"`
}

type Query struct {
}

type RemoveIntegrationFromWorkspaceInput struct {
	WorkspaceID   ID `json:"workspaceId"`
	IntegrationID ID `json:"integrationId"`
}

type RemoveMemberFromWorkspacePayload struct {
	Workspace *Workspace `json:"workspace"`
}

type RemoveMyAuthInput struct {
	Auth string `json:"auth"`
}

type RemoveUserFromWorkspaceInput struct {
	WorkspaceID ID `json:"workspaceId"`
	UserID      ID `json:"userId"`
}

type Request struct {
	ID          ID             `json:"id"`
	Items       []*RequestItem `json:"items"`
	Title       string         `json:"title"`
	Description *string        `json:"description,omitempty"`
	CreatedByID ID             `json:"createdById"`
	WorkspaceID ID             `json:"workspaceId"`
	ProjectID   ID             `json:"projectId"`
	ThreadID    ID             `json:"threadId"`
	ReviewersID []ID           `json:"reviewersId"`
	State       RequestState   `json:"state"`
	CreatedAt   time.Time      `json:"createdAt"`
	UpdatedAt   time.Time      `json:"updatedAt"`
	ApprovedAt  *time.Time     `json:"approvedAt,omitempty"`
	ClosedAt    *time.Time     `json:"closedAt,omitempty"`
	Thread      *Thread        `json:"thread,omitempty"`
	CreatedBy   *User          `json:"createdBy,omitempty"`
	Workspace   *Workspace     `json:"workspace,omitempty"`
	Project     *Project       `json:"project,omitempty"`
	Reviewers   []*User        `json:"reviewers"`
}

func (Request) IsNode()        {}
func (this Request) GetID() ID { return this.ID }

type RequestConnection struct {
	Edges      []*RequestEdge `json:"edges"`
	Nodes      []*Request     `json:"nodes"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type RequestEdge struct {
	Cursor usecasex.Cursor `json:"cursor"`
	Node   *Request        `json:"node,omitempty"`
}

type RequestItem struct {
	ItemID  ID             `json:"itemId"`
	Version *string        `json:"version,omitempty"`
	Ref     *string        `json:"ref,omitempty"`
	Item    *VersionedItem `json:"item,omitempty"`
}

type RequestItemInput struct {
	ItemID ID `json:"itemId"`
}

type RequestPayload struct {
	Request *Request `json:"request"`
}

type ResourceInput struct {
	Tile    *TileResourceInput    `json:"tile,omitempty"`
	Terrain *TerrainResourceInput `json:"terrain,omitempty"`
}

type ResourceList struct {
	Resources        []Resource `json:"resources"`
	SelectedResource *ID        `json:"selectedResource,omitempty"`
	Enabled          *bool      `json:"enabled,omitempty"`
}

type ResourcesListInput struct {
	Resources        []*ResourceInput `json:"resources"`
	SelectedResource *ID              `json:"selectedResource,omitempty"`
	Enabled          *bool            `json:"enabled,omitempty"`
}

type Schema struct {
	ID           ID             `json:"id"`
	ProjectID    ID             `json:"projectId"`
	Fields       []*SchemaField `json:"fields"`
	TitleFieldID *ID            `json:"titleFieldId,omitempty"`
	TitleField   *SchemaField   `json:"titleField,omitempty"`
	Project      *Project       `json:"project"`
}

func (Schema) IsNode()        {}
func (this Schema) GetID() ID { return this.ID }

type SchemaField struct {
	ID           ID                      `json:"id"`
	ModelID      *ID                     `json:"modelId,omitempty"`
	GroupID      *ID                     `json:"groupId,omitempty"`
	Model        *Model                  `json:"model,omitempty"`
	Group        *Group                  `json:"group,omitempty"`
	Type         SchemaFieldType         `json:"type"`
	TypeProperty SchemaFieldTypeProperty `json:"typeProperty,omitempty"`
	Key          string                  `json:"key"`
	Title        string                  `json:"title"`
	Order        *int                    `json:"order,omitempty"`
	Description  *string                 `json:"description,omitempty"`
	Multiple     bool                    `json:"multiple"`
	Unique       bool                    `json:"unique"`
	Required     bool                    `json:"required"`
	IsTitle      bool                    `json:"isTitle"`
	CreatedAt    time.Time               `json:"createdAt"`
	UpdatedAt    time.Time               `json:"updatedAt"`
}

type SchemaFieldAsset struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

func (SchemaFieldAsset) IsSchemaFieldTypeProperty() {}

type SchemaFieldAssetInput struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

type SchemaFieldBool struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

func (SchemaFieldBool) IsSchemaFieldTypeProperty() {}

type SchemaFieldBoolInput struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

type SchemaFieldCheckbox struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

func (SchemaFieldCheckbox) IsSchemaFieldTypeProperty() {}

type SchemaFieldCheckboxInput struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

type SchemaFieldDate struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

func (SchemaFieldDate) IsSchemaFieldTypeProperty() {}

type SchemaFieldDateInput struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

type SchemaFieldGroup struct {
	GroupID ID `json:"groupId"`
}

func (SchemaFieldGroup) IsSchemaFieldTypeProperty() {}

type SchemaFieldGroupInput struct {
	GroupID ID `json:"groupId"`
}

type SchemaFieldInteger struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	Min          *int        `json:"min,omitempty"`
	Max          *int        `json:"max,omitempty"`
}

func (SchemaFieldInteger) IsSchemaFieldTypeProperty() {}

type SchemaFieldIntegerInput struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	Min          *int        `json:"min,omitempty"`
	Max          *int        `json:"max,omitempty"`
}

type SchemaFieldMarkdown struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	MaxLength    *int        `json:"maxLength,omitempty"`
}

func (SchemaFieldMarkdown) IsSchemaFieldTypeProperty() {}

type SchemaFieldReference struct {
	ModelID              ID           `json:"modelId"`
	SchemaID             ID           `json:"schemaId"`
	Schema               *Schema      `json:"schema"`
	CorrespondingFieldID *ID          `json:"correspondingFieldId,omitempty"`
	CorrespondingField   *SchemaField `json:"correspondingField,omitempty"`
}

func (SchemaFieldReference) IsSchemaFieldTypeProperty() {}

type SchemaFieldReferenceInput struct {
	ModelID            ID                       `json:"modelId"`
	SchemaID           ID                       `json:"schemaId"`
	CorrespondingField *CorrespondingFieldInput `json:"correspondingField,omitempty"`
}

type SchemaFieldRichText struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	MaxLength    *int        `json:"maxLength,omitempty"`
}

func (SchemaFieldRichText) IsSchemaFieldTypeProperty() {}

type SchemaFieldRichTextInput struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	MaxLength    *int        `json:"maxLength,omitempty"`
}

type SchemaFieldSelect struct {
	Values       []string    `json:"values"`
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

func (SchemaFieldSelect) IsSchemaFieldTypeProperty() {}

type SchemaFieldSelectInput struct {
	Values       []string    `json:"values"`
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

type SchemaFieldTag struct {
	Tags         []*SchemaFieldTagValue `json:"tags"`
	DefaultValue interface{}            `json:"defaultValue,omitempty"`
}

func (SchemaFieldTag) IsSchemaFieldTypeProperty() {}

type SchemaFieldTagInput struct {
	Tags         []*SchemaFieldTagValueInput `json:"tags"`
	DefaultValue interface{}                 `json:"defaultValue,omitempty"`
}

type SchemaFieldTagValue struct {
	ID    ID                  `json:"id"`
	Name  string              `json:"name"`
	Color SchemaFieldTagColor `json:"color"`
}

type SchemaFieldTagValueInput struct {
	ID    *ID                  `json:"id,omitempty"`
	Name  *string              `json:"name,omitempty"`
	Color *SchemaFieldTagColor `json:"color,omitempty"`
}

type SchemaFieldText struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	MaxLength    *int        `json:"maxLength,omitempty"`
}

func (SchemaFieldText) IsSchemaFieldTypeProperty() {}

type SchemaFieldTextArea struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	MaxLength    *int        `json:"maxLength,omitempty"`
}

func (SchemaFieldTextArea) IsSchemaFieldTypeProperty() {}

type SchemaFieldTextAreaInput struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	MaxLength    *int        `json:"maxLength,omitempty"`
}

type SchemaFieldTextInput struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	MaxLength    *int        `json:"maxLength,omitempty"`
}

type SchemaFieldTypePropertyInput struct {
	Text         *SchemaFieldTextInput      `json:"text,omitempty"`
	TextArea     *SchemaFieldTextAreaInput  `json:"textArea,omitempty"`
	RichText     *SchemaFieldRichTextInput  `json:"richText,omitempty"`
	MarkdownText *SchemaMarkdownTextInput   `json:"markdownText,omitempty"`
	Asset        *SchemaFieldAssetInput     `json:"asset,omitempty"`
	Date         *SchemaFieldDateInput      `json:"date,omitempty"`
	Bool         *SchemaFieldBoolInput      `json:"bool,omitempty"`
	Select       *SchemaFieldSelectInput    `json:"select,omitempty"`
	Tag          *SchemaFieldTagInput       `json:"tag,omitempty"`
	Checkbox     *SchemaFieldCheckboxInput  `json:"checkbox,omitempty"`
	Integer      *SchemaFieldIntegerInput   `json:"integer,omitempty"`
	Reference    *SchemaFieldReferenceInput `json:"reference,omitempty"`
	URL          *SchemaFieldURLInput       `json:"url,omitempty"`
	Group        *SchemaFieldGroupInput     `json:"group,omitempty"`
}

type SchemaFieldURL struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

func (SchemaFieldURL) IsSchemaFieldTypeProperty() {}

type SchemaFieldURLInput struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
}

type SchemaMarkdownTextInput struct {
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	MaxLength    *int        `json:"maxLength,omitempty"`
}

type SearchItemInput struct {
	Query      *ItemQueryInput `json:"query"`
	Sort       *ItemSortInput  `json:"sort,omitempty"`
	Filter     *ConditionInput `json:"filter,omitempty"`
	Pagination *Pagination     `json:"pagination,omitempty"`
}

type Sort struct {
	Key      string `json:"key"`
	Reverted *bool  `json:"reverted,omitempty"`
}

type StringFieldCondition struct {
	FieldID  *FieldSelector `json:"fieldId"`
	Operator StringOperator `json:"operator"`
	Value    string         `json:"value"`
}

func (StringFieldCondition) IsCondition() {}

type StringFieldConditionInput struct {
	FieldID  *FieldSelectorInput `json:"fieldId"`
	Operator StringOperator      `json:"operator"`
	Value    string              `json:"value"`
}

type TerrainResource struct {
	ID    ID                   `json:"id"`
	Type  TerrainType          `json:"type"`
	Props *CesiumResourceProps `json:"props,omitempty"`
}

func (TerrainResource) IsResource() {}

type TerrainResourceInput struct {
	ID    ID                        `json:"id"`
	Type  TerrainType               `json:"type"`
	Props *CesiumResourcePropsInput `json:"props,omitempty"`
}

type Thread struct {
	ID          ID         `json:"id"`
	Workspace   *Workspace `json:"workspace,omitempty"`
	WorkspaceID ID         `json:"workspaceId"`
	Comments    []*Comment `json:"comments"`
}

type ThreadPayload struct {
	Thread *Thread `json:"thread"`
}

type TileResource struct {
	ID    ID                `json:"id"`
	Type  TileType          `json:"type"`
	Props *URLResourceProps `json:"props,omitempty"`
}

func (TileResource) IsResource() {}

type TileResourceInput struct {
	ID    ID                     `json:"id"`
	Type  TileType               `json:"type"`
	Props *URLResourcePropsInput `json:"props,omitempty"`
}

type TimeFieldCondition struct {
	FieldID  *FieldSelector `json:"fieldId"`
	Operator TimeOperator   `json:"operator"`
	Value    time.Time      `json:"value"`
}

func (TimeFieldCondition) IsCondition() {}

type TimeFieldConditionInput struct {
	FieldID  *FieldSelectorInput `json:"fieldId"`
	Operator TimeOperator        `json:"operator"`
	Value    time.Time           `json:"value"`
}

type UnpublishItemInput struct {
	ItemIds []ID `json:"itemIds"`
}

type UnpublishItemPayload struct {
	Items []*Item `json:"items"`
}

type UpdateAssetInput struct {
	ID          ID           `json:"id"`
	PreviewType *PreviewType `json:"previewType,omitempty"`
}

type UpdateAssetPayload struct {
	Asset *Asset `json:"asset"`
}

type UpdateCommentInput struct {
	ThreadID  ID     `json:"threadId"`
	CommentID ID     `json:"commentId"`
	Content   string `json:"content"`
}

type UpdateFieldInput struct {
	ModelID      *ID                           `json:"modelId,omitempty"`
	GroupID      *ID                           `json:"groupId,omitempty"`
	FieldID      ID                            `json:"fieldId"`
	Title        *string                       `json:"title,omitempty"`
	Description  *string                       `json:"description,omitempty"`
	Order        *int                          `json:"order,omitempty"`
	Metadata     *bool                         `json:"metadata,omitempty"`
	Key          *string                       `json:"key,omitempty"`
	Required     *bool                         `json:"required,omitempty"`
	Unique       *bool                         `json:"unique,omitempty"`
	Multiple     *bool                         `json:"multiple,omitempty"`
	IsTitle      *bool                         `json:"isTitle,omitempty"`
	TypeProperty *SchemaFieldTypePropertyInput `json:"typeProperty,omitempty"`
}

type UpdateGroupInput struct {
	GroupID     ID      `json:"groupId"`
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	Key         *string `json:"key,omitempty"`
}

type UpdateIntegrationInput struct {
	IntegrationID ID       `json:"integrationId"`
	Name          *string  `json:"name,omitempty"`
	Description   *string  `json:"description,omitempty"`
	LogoURL       *url.URL `json:"logoUrl,omitempty"`
}

type UpdateIntegrationOfWorkspaceInput struct {
	WorkspaceID   ID   `json:"workspaceId"`
	IntegrationID ID   `json:"integrationId"`
	Role          Role `json:"role"`
}

type UpdateItemInput struct {
	ItemID     ID                `json:"itemId"`
	MetadataID *ID               `json:"metadataId,omitempty"`
	OriginalID *ID               `json:"originalId,omitempty"`
	Fields     []*ItemFieldInput `json:"fields"`
	Version    *string           `json:"version,omitempty"`
}

type UpdateMeInput struct {
	Name                 *string       `json:"name,omitempty"`
	Email                *string       `json:"email,omitempty"`
	Lang                 *language.Tag `json:"lang,omitempty"`
	Theme                *Theme        `json:"theme,omitempty"`
	Password             *string       `json:"password,omitempty"`
	PasswordConfirmation *string       `json:"passwordConfirmation,omitempty"`
}

type UpdateMePayload struct {
	Me *Me `json:"me"`
}

type UpdateMemberOfWorkspacePayload struct {
	Workspace *Workspace `json:"workspace"`
}

type UpdateModelInput struct {
	ModelID     ID      `json:"modelId"`
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	Key         *string `json:"key,omitempty"`
	Public      bool    `json:"public"`
}

type UpdateModelsOrderInput struct {
	ModelIds []ID `json:"modelIds"`
}

type UpdateProjectInput struct {
	ProjectID    ID                             `json:"projectId"`
	Name         *string                        `json:"name,omitempty"`
	Description  *string                        `json:"description,omitempty"`
	Alias        *string                        `json:"alias,omitempty"`
	Publication  *UpdateProjectPublicationInput `json:"publication,omitempty"`
	RequestRoles []Role                         `json:"requestRoles,omitempty"`
}

type UpdateProjectPublicationInput struct {
	Scope       *ProjectPublicationScope `json:"scope,omitempty"`
	AssetPublic *bool                    `json:"assetPublic,omitempty"`
}

type UpdateRequestInput struct {
	RequestID   ID                  `json:"requestId"`
	Title       *string             `json:"title,omitempty"`
	Description *string             `json:"description,omitempty"`
	State       *RequestState       `json:"state,omitempty"`
	ReviewersID []ID                `json:"reviewersId,omitempty"`
	Items       []*RequestItemInput `json:"items,omitempty"`
}

type UpdateUserOfWorkspaceInput struct {
	WorkspaceID ID   `json:"workspaceId"`
	UserID      ID   `json:"userId"`
	Role        Role `json:"role"`
}

type UpdateViewInput struct {
	ViewID  ID                      `json:"viewId"`
	Name    *string                 `json:"name,omitempty"`
	Sort    *ItemSortInput          `json:"sort,omitempty"`
	Filter  *ConditionInput         `json:"filter,omitempty"`
	Columns []*ColumnSelectionInput `json:"columns,omitempty"`
}

type UpdateWebhookInput struct {
	IntegrationID ID                   `json:"integrationId"`
	WebhookID     ID                   `json:"webhookId"`
	Name          *string              `json:"name,omitempty"`
	URL           *url.URL             `json:"url,omitempty"`
	Active        *bool                `json:"active,omitempty"`
	Trigger       *WebhookTriggerInput `json:"trigger,omitempty"`
	Secret        *string              `json:"secret,omitempty"`
}

type UpdateWorkspaceInput struct {
	WorkspaceID ID     `json:"workspaceId"`
	Name        string `json:"name"`
}

type UpdateWorkspacePayload struct {
	Workspace *Workspace `json:"workspace"`
}

type UpdateWorkspaceSettingsInput struct {
	ID       ID                  `json:"id"`
	Tiles    *ResourcesListInput `json:"tiles,omitempty"`
	Terrains *ResourcesListInput `json:"terrains,omitempty"`
}

type UpdateWorkspaceSettingsPayload struct {
	WorkspaceSettings *WorkspaceSettings `json:"workspaceSettings"`
}

type URLResourceProps struct {
	Name  string `json:"name"`
	URL   string `json:"url"`
	Image string `json:"image"`
}

type URLResourcePropsInput struct {
	Name  string `json:"name"`
	URL   string `json:"url"`
	Image string `json:"image"`
}

type User struct {
	ID    ID      `json:"id"`
	Name  string  `json:"name"`
	Email string  `json:"email"`
	Host  *string `json:"host,omitempty"`
}

func (User) IsOperator() {}

func (User) IsNode()        {}
func (this User) GetID() ID { return this.ID }

type VersionedItem struct {
	Version string   `json:"version"`
	Parents []string `json:"parents,omitempty"`
	Refs    []string `json:"refs"`
	Value   *Item    `json:"value"`
}

type View struct {
	ID        ID        `json:"id"`
	Name      string    `json:"name"`
	ModelID   ID        `json:"modelId"`
	ProjectID ID        `json:"projectId"`
	Sort      *ItemSort `json:"sort,omitempty"`
	Filter    Condition `json:"filter,omitempty"`
	Columns   []*Column `json:"columns,omitempty"`
}

func (View) IsNode()        {}
func (this View) GetID() ID { return this.ID }

type ViewPayload struct {
	View *View `json:"view"`
}

type Webhook struct {
	ID        ID              `json:"id"`
	Name      string          `json:"name"`
	URL       url.URL         `json:"url"`
	Active    bool            `json:"active"`
	Trigger   *WebhookTrigger `json:"trigger"`
	Secret    string          `json:"secret"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
}

type WebhookPayload struct {
	Webhook *Webhook `json:"webhook"`
}

type WebhookTrigger struct {
	OnItemCreate      *bool `json:"onItemCreate,omitempty"`
	OnItemUpdate      *bool `json:"onItemUpdate,omitempty"`
	OnItemDelete      *bool `json:"onItemDelete,omitempty"`
	OnItemPublish     *bool `json:"onItemPublish,omitempty"`
	OnItemUnPublish   *bool `json:"onItemUnPublish,omitempty"`
	OnAssetUpload     *bool `json:"onAssetUpload,omitempty"`
	OnAssetDecompress *bool `json:"onAssetDecompress,omitempty"`
	OnAssetDelete     *bool `json:"onAssetDelete,omitempty"`
}

type WebhookTriggerInput struct {
	OnItemCreate      *bool `json:"onItemCreate,omitempty"`
	OnItemUpdate      *bool `json:"onItemUpdate,omitempty"`
	OnItemDelete      *bool `json:"onItemDelete,omitempty"`
	OnItemPublish     *bool `json:"onItemPublish,omitempty"`
	OnItemUnPublish   *bool `json:"onItemUnPublish,omitempty"`
	OnAssetUpload     *bool `json:"onAssetUpload,omitempty"`
	OnAssetDecompress *bool `json:"onAssetDecompress,omitempty"`
	OnAssetDelete     *bool `json:"onAssetDelete,omitempty"`
}

type Workspace struct {
	ID       ID                `json:"id"`
	Name     string            `json:"name"`
	Members  []WorkspaceMember `json:"members"`
	Personal bool              `json:"personal"`
}

func (Workspace) IsNode()        {}
func (this Workspace) GetID() ID { return this.ID }

type WorkspaceIntegrationMember struct {
	IntegrationID ID           `json:"integrationId"`
	Role          Role         `json:"role"`
	Active        bool         `json:"active"`
	InvitedByID   ID           `json:"invitedById"`
	InvitedBy     *User        `json:"invitedBy,omitempty"`
	Integration   *Integration `json:"integration,omitempty"`
}

func (WorkspaceIntegrationMember) IsWorkspaceMember() {}

type WorkspaceSettings struct {
	ID       ID            `json:"id"`
	Tiles    *ResourceList `json:"tiles,omitempty"`
	Terrains *ResourceList `json:"terrains,omitempty"`
}

func (WorkspaceSettings) IsNode()        {}
func (this WorkspaceSettings) GetID() ID { return this.ID }

type WorkspaceUserMember struct {
	UserID ID      `json:"userId"`
	Role   Role    `json:"role"`
	Host   *string `json:"host,omitempty"`
	User   *User   `json:"user,omitempty"`
}

func (WorkspaceUserMember) IsWorkspaceMember() {}

type ArchiveExtractionStatus string

const (
	ArchiveExtractionStatusSkipped    ArchiveExtractionStatus = "SKIPPED"
	ArchiveExtractionStatusPending    ArchiveExtractionStatus = "PENDING"
	ArchiveExtractionStatusInProgress ArchiveExtractionStatus = "IN_PROGRESS"
	ArchiveExtractionStatusDone       ArchiveExtractionStatus = "DONE"
	ArchiveExtractionStatusFailed     ArchiveExtractionStatus = "FAILED"
)

var AllArchiveExtractionStatus = []ArchiveExtractionStatus{
	ArchiveExtractionStatusSkipped,
	ArchiveExtractionStatusPending,
	ArchiveExtractionStatusInProgress,
	ArchiveExtractionStatusDone,
	ArchiveExtractionStatusFailed,
}

func (e ArchiveExtractionStatus) IsValid() bool {
	switch e {
	case ArchiveExtractionStatusSkipped, ArchiveExtractionStatusPending, ArchiveExtractionStatusInProgress, ArchiveExtractionStatusDone, ArchiveExtractionStatusFailed:
		return true
	}
	return false
}

func (e ArchiveExtractionStatus) String() string {
	return string(e)
}

func (e *ArchiveExtractionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ArchiveExtractionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ArchiveExtractionStatus", str)
	}
	return nil
}

func (e ArchiveExtractionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AssetSortType string

const (
	AssetSortTypeDate AssetSortType = "DATE"
	AssetSortTypeSize AssetSortType = "SIZE"
	AssetSortTypeName AssetSortType = "NAME"
)

var AllAssetSortType = []AssetSortType{
	AssetSortTypeDate,
	AssetSortTypeSize,
	AssetSortTypeName,
}

func (e AssetSortType) IsValid() bool {
	switch e {
	case AssetSortTypeDate, AssetSortTypeSize, AssetSortTypeName:
		return true
	}
	return false
}

func (e AssetSortType) String() string {
	return string(e)
}

func (e *AssetSortType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssetSortType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssetSortType", str)
	}
	return nil
}

func (e AssetSortType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BasicOperator string

const (
	BasicOperatorEquals    BasicOperator = "EQUALS"
	BasicOperatorNotEquals BasicOperator = "NOT_EQUALS"
)

var AllBasicOperator = []BasicOperator{
	BasicOperatorEquals,
	BasicOperatorNotEquals,
}

func (e BasicOperator) IsValid() bool {
	switch e {
	case BasicOperatorEquals, BasicOperatorNotEquals:
		return true
	}
	return false
}

func (e BasicOperator) String() string {
	return string(e)
}

func (e *BasicOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BasicOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BasicOperator", str)
	}
	return nil
}

func (e BasicOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BoolOperator string

const (
	BoolOperatorEquals    BoolOperator = "EQUALS"
	BoolOperatorNotEquals BoolOperator = "NOT_EQUALS"
)

var AllBoolOperator = []BoolOperator{
	BoolOperatorEquals,
	BoolOperatorNotEquals,
}

func (e BoolOperator) IsValid() bool {
	switch e {
	case BoolOperatorEquals, BoolOperatorNotEquals:
		return true
	}
	return false
}

func (e BoolOperator) String() string {
	return string(e)
}

func (e *BoolOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BoolOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BoolOperator", str)
	}
	return nil
}

func (e BoolOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FieldType string

const (
	FieldTypeID               FieldType = "ID"
	FieldTypeCreationDate     FieldType = "CREATION_DATE"
	FieldTypeCreationUser     FieldType = "CREATION_USER"
	FieldTypeModificationDate FieldType = "MODIFICATION_DATE"
	FieldTypeModificationUser FieldType = "MODIFICATION_USER"
	FieldTypeStatus           FieldType = "STATUS"
	FieldTypeField            FieldType = "FIELD"
	FieldTypeMetaField        FieldType = "META_FIELD"
)

var AllFieldType = []FieldType{
	FieldTypeID,
	FieldTypeCreationDate,
	FieldTypeCreationUser,
	FieldTypeModificationDate,
	FieldTypeModificationUser,
	FieldTypeStatus,
	FieldTypeField,
	FieldTypeMetaField,
}

func (e FieldType) IsValid() bool {
	switch e {
	case FieldTypeID, FieldTypeCreationDate, FieldTypeCreationUser, FieldTypeModificationDate, FieldTypeModificationUser, FieldTypeStatus, FieldTypeField, FieldTypeMetaField:
		return true
	}
	return false
}

func (e FieldType) String() string {
	return string(e)
}

func (e *FieldType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FieldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FieldType", str)
	}
	return nil
}

func (e FieldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IntegrationType string

const (
	IntegrationTypePublic  IntegrationType = "Public"
	IntegrationTypePrivate IntegrationType = "Private"
)

var AllIntegrationType = []IntegrationType{
	IntegrationTypePublic,
	IntegrationTypePrivate,
}

func (e IntegrationType) IsValid() bool {
	switch e {
	case IntegrationTypePublic, IntegrationTypePrivate:
		return true
	}
	return false
}

func (e IntegrationType) String() string {
	return string(e)
}

func (e *IntegrationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationType", str)
	}
	return nil
}

func (e IntegrationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ItemStatus string

const (
	ItemStatusDraft        ItemStatus = "DRAFT"
	ItemStatusPublic       ItemStatus = "PUBLIC"
	ItemStatusReview       ItemStatus = "REVIEW"
	ItemStatusPublicReview ItemStatus = "PUBLIC_REVIEW"
	ItemStatusPublicDraft  ItemStatus = "PUBLIC_DRAFT"
)

var AllItemStatus = []ItemStatus{
	ItemStatusDraft,
	ItemStatusPublic,
	ItemStatusReview,
	ItemStatusPublicReview,
	ItemStatusPublicDraft,
}

func (e ItemStatus) IsValid() bool {
	switch e {
	case ItemStatusDraft, ItemStatusPublic, ItemStatusReview, ItemStatusPublicReview, ItemStatusPublicDraft:
		return true
	}
	return false
}

func (e ItemStatus) String() string {
	return string(e)
}

func (e *ItemStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemStatus", str)
	}
	return nil
}

func (e ItemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MultipleOperator string

const (
	MultipleOperatorIncludesAny    MultipleOperator = "INCLUDES_ANY"
	MultipleOperatorNotIncludesAny MultipleOperator = "NOT_INCLUDES_ANY"
	MultipleOperatorIncludesAll    MultipleOperator = "INCLUDES_ALL"
	MultipleOperatorNotIncludesAll MultipleOperator = "NOT_INCLUDES_ALL"
)

var AllMultipleOperator = []MultipleOperator{
	MultipleOperatorIncludesAny,
	MultipleOperatorNotIncludesAny,
	MultipleOperatorIncludesAll,
	MultipleOperatorNotIncludesAll,
}

func (e MultipleOperator) IsValid() bool {
	switch e {
	case MultipleOperatorIncludesAny, MultipleOperatorNotIncludesAny, MultipleOperatorIncludesAll, MultipleOperatorNotIncludesAll:
		return true
	}
	return false
}

func (e MultipleOperator) String() string {
	return string(e)
}

func (e *MultipleOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MultipleOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MultipleOperator", str)
	}
	return nil
}

func (e MultipleOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeType string

const (
	NodeTypeUser              NodeType = "USER"
	NodeTypeWorkspace         NodeType = "WORKSPACE"
	NodeTypeProject           NodeType = "PROJECT"
	NodeTypeAsset             NodeType = "ASSET"
	NodeTypeRequest           NodeType = "REQUEST"
	NodeTypeModel             NodeType = "Model"
	NodeTypeSchema            NodeType = "Schema"
	NodeTypeItem              NodeType = "Item"
	NodeTypeView              NodeType = "View"
	NodeTypeIntegration       NodeType = "Integration"
	NodeTypeGroup             NodeType = "Group"
	NodeTypeWorkspaceSettings NodeType = "WorkspaceSettings"
)

var AllNodeType = []NodeType{
	NodeTypeUser,
	NodeTypeWorkspace,
	NodeTypeProject,
	NodeTypeAsset,
	NodeTypeRequest,
	NodeTypeModel,
	NodeTypeSchema,
	NodeTypeItem,
	NodeTypeView,
	NodeTypeIntegration,
	NodeTypeGroup,
	NodeTypeWorkspaceSettings,
}

func (e NodeType) IsValid() bool {
	switch e {
	case NodeTypeUser, NodeTypeWorkspace, NodeTypeProject, NodeTypeAsset, NodeTypeRequest, NodeTypeModel, NodeTypeSchema, NodeTypeItem, NodeTypeView, NodeTypeIntegration, NodeTypeGroup, NodeTypeWorkspaceSettings:
		return true
	}
	return false
}

func (e NodeType) String() string {
	return string(e)
}

func (e *NodeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeType", str)
	}
	return nil
}

func (e NodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NullableOperator string

const (
	NullableOperatorEmpty    NullableOperator = "EMPTY"
	NullableOperatorNotEmpty NullableOperator = "NOT_EMPTY"
)

var AllNullableOperator = []NullableOperator{
	NullableOperatorEmpty,
	NullableOperatorNotEmpty,
}

func (e NullableOperator) IsValid() bool {
	switch e {
	case NullableOperatorEmpty, NullableOperatorNotEmpty:
		return true
	}
	return false
}

func (e NullableOperator) String() string {
	return string(e)
}

func (e *NullableOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NullableOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NullableOperator", str)
	}
	return nil
}

func (e NullableOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NumberOperator string

const (
	NumberOperatorGreaterThan          NumberOperator = "GREATER_THAN"
	NumberOperatorLessThan             NumberOperator = "LESS_THAN"
	NumberOperatorGreaterThanOrEqualTo NumberOperator = "GREATER_THAN_OR_EQUAL_TO"
	NumberOperatorLessThanOrEqualTo    NumberOperator = "LESS_THAN_OR_EQUAL_TO"
)

var AllNumberOperator = []NumberOperator{
	NumberOperatorGreaterThan,
	NumberOperatorLessThan,
	NumberOperatorGreaterThanOrEqualTo,
	NumberOperatorLessThanOrEqualTo,
}

func (e NumberOperator) IsValid() bool {
	switch e {
	case NumberOperatorGreaterThan, NumberOperatorLessThan, NumberOperatorGreaterThanOrEqualTo, NumberOperatorLessThanOrEqualTo:
		return true
	}
	return false
}

func (e NumberOperator) String() string {
	return string(e)
}

func (e *NumberOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NumberOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NumberOperator", str)
	}
	return nil
}

func (e NumberOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperatorType string

const (
	OperatorTypeUser        OperatorType = "User"
	OperatorTypeIntegration OperatorType = "Integration"
)

var AllOperatorType = []OperatorType{
	OperatorTypeUser,
	OperatorTypeIntegration,
}

func (e OperatorType) IsValid() bool {
	switch e {
	case OperatorTypeUser, OperatorTypeIntegration:
		return true
	}
	return false
}

func (e OperatorType) String() string {
	return string(e)
}

func (e *OperatorType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperatorType", str)
	}
	return nil
}

func (e OperatorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PreviewType string

const (
	PreviewTypeImage      PreviewType = "IMAGE"
	PreviewTypeImageSVG   PreviewType = "IMAGE_SVG"
	PreviewTypeGeo        PreviewType = "GEO"
	PreviewTypeGeo3dTiles PreviewType = "GEO_3D_TILES"
	PreviewTypeGeoMvt     PreviewType = "GEO_MVT"
	PreviewTypeModel3d    PreviewType = "MODEL_3D"
	PreviewTypeUnknown    PreviewType = "UNKNOWN"
)

var AllPreviewType = []PreviewType{
	PreviewTypeImage,
	PreviewTypeImageSVG,
	PreviewTypeGeo,
	PreviewTypeGeo3dTiles,
	PreviewTypeGeoMvt,
	PreviewTypeModel3d,
	PreviewTypeUnknown,
}

func (e PreviewType) IsValid() bool {
	switch e {
	case PreviewTypeImage, PreviewTypeImageSVG, PreviewTypeGeo, PreviewTypeGeo3dTiles, PreviewTypeGeoMvt, PreviewTypeModel3d, PreviewTypeUnknown:
		return true
	}
	return false
}

func (e PreviewType) String() string {
	return string(e)
}

func (e *PreviewType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PreviewType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PreviewType", str)
	}
	return nil
}

func (e PreviewType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectPublicationScope string

const (
	ProjectPublicationScopePublic  ProjectPublicationScope = "PUBLIC"
	ProjectPublicationScopeLimited ProjectPublicationScope = "LIMITED"
	ProjectPublicationScopePrivate ProjectPublicationScope = "PRIVATE"
)

var AllProjectPublicationScope = []ProjectPublicationScope{
	ProjectPublicationScopePublic,
	ProjectPublicationScopeLimited,
	ProjectPublicationScopePrivate,
}

func (e ProjectPublicationScope) IsValid() bool {
	switch e {
	case ProjectPublicationScopePublic, ProjectPublicationScopeLimited, ProjectPublicationScopePrivate:
		return true
	}
	return false
}

func (e ProjectPublicationScope) String() string {
	return string(e)
}

func (e *ProjectPublicationScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectPublicationScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectPublicationScope", str)
	}
	return nil
}

func (e ProjectPublicationScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RequestState string

const (
	RequestStateDraft    RequestState = "DRAFT"
	RequestStateWaiting  RequestState = "WAITING"
	RequestStateClosed   RequestState = "CLOSED"
	RequestStateApproved RequestState = "APPROVED"
)

var AllRequestState = []RequestState{
	RequestStateDraft,
	RequestStateWaiting,
	RequestStateClosed,
	RequestStateApproved,
}

func (e RequestState) IsValid() bool {
	switch e {
	case RequestStateDraft, RequestStateWaiting, RequestStateClosed, RequestStateApproved:
		return true
	}
	return false
}

func (e RequestState) String() string {
	return string(e)
}

func (e *RequestState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RequestState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RequestState", str)
	}
	return nil
}

func (e RequestState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Role string

const (
	RoleReader     Role = "READER"
	RoleWriter     Role = "WRITER"
	RoleOwner      Role = "OWNER"
	RoleMaintainer Role = "MAINTAINER"
)

var AllRole = []Role{
	RoleReader,
	RoleWriter,
	RoleOwner,
	RoleMaintainer,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleReader, RoleWriter, RoleOwner, RoleMaintainer:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SchemaFieldTagColor string

const (
	SchemaFieldTagColorMagenta  SchemaFieldTagColor = "MAGENTA"
	SchemaFieldTagColorRed      SchemaFieldTagColor = "RED"
	SchemaFieldTagColorVolcano  SchemaFieldTagColor = "VOLCANO"
	SchemaFieldTagColorOrange   SchemaFieldTagColor = "ORANGE"
	SchemaFieldTagColorGold     SchemaFieldTagColor = "GOLD"
	SchemaFieldTagColorLime     SchemaFieldTagColor = "LIME"
	SchemaFieldTagColorGreen    SchemaFieldTagColor = "GREEN"
	SchemaFieldTagColorCyan     SchemaFieldTagColor = "CYAN"
	SchemaFieldTagColorBlue     SchemaFieldTagColor = "BLUE"
	SchemaFieldTagColorGeekblue SchemaFieldTagColor = "GEEKBLUE"
	SchemaFieldTagColorPurple   SchemaFieldTagColor = "PURPLE"
)

var AllSchemaFieldTagColor = []SchemaFieldTagColor{
	SchemaFieldTagColorMagenta,
	SchemaFieldTagColorRed,
	SchemaFieldTagColorVolcano,
	SchemaFieldTagColorOrange,
	SchemaFieldTagColorGold,
	SchemaFieldTagColorLime,
	SchemaFieldTagColorGreen,
	SchemaFieldTagColorCyan,
	SchemaFieldTagColorBlue,
	SchemaFieldTagColorGeekblue,
	SchemaFieldTagColorPurple,
}

func (e SchemaFieldTagColor) IsValid() bool {
	switch e {
	case SchemaFieldTagColorMagenta, SchemaFieldTagColorRed, SchemaFieldTagColorVolcano, SchemaFieldTagColorOrange, SchemaFieldTagColorGold, SchemaFieldTagColorLime, SchemaFieldTagColorGreen, SchemaFieldTagColorCyan, SchemaFieldTagColorBlue, SchemaFieldTagColorGeekblue, SchemaFieldTagColorPurple:
		return true
	}
	return false
}

func (e SchemaFieldTagColor) String() string {
	return string(e)
}

func (e *SchemaFieldTagColor) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SchemaFieldTagColor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SchemaFieldTagColor", str)
	}
	return nil
}

func (e SchemaFieldTagColor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SchemaFieldType string

const (
	SchemaFieldTypeText         SchemaFieldType = "Text"
	SchemaFieldTypeTextArea     SchemaFieldType = "TextArea"
	SchemaFieldTypeRichText     SchemaFieldType = "RichText"
	SchemaFieldTypeMarkdownText SchemaFieldType = "MarkdownText"
	SchemaFieldTypeAsset        SchemaFieldType = "Asset"
	SchemaFieldTypeDate         SchemaFieldType = "Date"
	SchemaFieldTypeBool         SchemaFieldType = "Bool"
	SchemaFieldTypeSelect       SchemaFieldType = "Select"
	SchemaFieldTypeTag          SchemaFieldType = "Tag"
	SchemaFieldTypeInteger      SchemaFieldType = "Integer"
	SchemaFieldTypeReference    SchemaFieldType = "Reference"
	SchemaFieldTypeCheckbox     SchemaFieldType = "Checkbox"
	SchemaFieldTypeURL          SchemaFieldType = "URL"
	SchemaFieldTypeGroup        SchemaFieldType = "Group"
)

var AllSchemaFieldType = []SchemaFieldType{
	SchemaFieldTypeText,
	SchemaFieldTypeTextArea,
	SchemaFieldTypeRichText,
	SchemaFieldTypeMarkdownText,
	SchemaFieldTypeAsset,
	SchemaFieldTypeDate,
	SchemaFieldTypeBool,
	SchemaFieldTypeSelect,
	SchemaFieldTypeTag,
	SchemaFieldTypeInteger,
	SchemaFieldTypeReference,
	SchemaFieldTypeCheckbox,
	SchemaFieldTypeURL,
	SchemaFieldTypeGroup,
}

func (e SchemaFieldType) IsValid() bool {
	switch e {
	case SchemaFieldTypeText, SchemaFieldTypeTextArea, SchemaFieldTypeRichText, SchemaFieldTypeMarkdownText, SchemaFieldTypeAsset, SchemaFieldTypeDate, SchemaFieldTypeBool, SchemaFieldTypeSelect, SchemaFieldTypeTag, SchemaFieldTypeInteger, SchemaFieldTypeReference, SchemaFieldTypeCheckbox, SchemaFieldTypeURL, SchemaFieldTypeGroup:
		return true
	}
	return false
}

func (e SchemaFieldType) String() string {
	return string(e)
}

func (e *SchemaFieldType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SchemaFieldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SchemaFieldType", str)
	}
	return nil
}

func (e SchemaFieldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StringOperator string

const (
	StringOperatorContains      StringOperator = "CONTAINS"
	StringOperatorNotContains   StringOperator = "NOT_CONTAINS"
	StringOperatorStartsWith    StringOperator = "STARTS_WITH"
	StringOperatorEndsWith      StringOperator = "ENDS_WITH"
	StringOperatorNotStartsWith StringOperator = "NOT_STARTS_WITH"
	StringOperatorNotEndsWith   StringOperator = "NOT_ENDS_WITH"
)

var AllStringOperator = []StringOperator{
	StringOperatorContains,
	StringOperatorNotContains,
	StringOperatorStartsWith,
	StringOperatorEndsWith,
	StringOperatorNotStartsWith,
	StringOperatorNotEndsWith,
}

func (e StringOperator) IsValid() bool {
	switch e {
	case StringOperatorContains, StringOperatorNotContains, StringOperatorStartsWith, StringOperatorEndsWith, StringOperatorNotStartsWith, StringOperatorNotEndsWith:
		return true
	}
	return false
}

func (e StringOperator) String() string {
	return string(e)
}

func (e *StringOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StringOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StringOperator", str)
	}
	return nil
}

func (e StringOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TerrainType string

const (
	TerrainTypeCesiumWorldTerrain TerrainType = "CESIUM_WORLD_TERRAIN"
	TerrainTypeArcGisTerrain      TerrainType = "ARC_GIS_TERRAIN"
	TerrainTypeCesiumIon          TerrainType = "CESIUM_ION"
)

var AllTerrainType = []TerrainType{
	TerrainTypeCesiumWorldTerrain,
	TerrainTypeArcGisTerrain,
	TerrainTypeCesiumIon,
}

func (e TerrainType) IsValid() bool {
	switch e {
	case TerrainTypeCesiumWorldTerrain, TerrainTypeArcGisTerrain, TerrainTypeCesiumIon:
		return true
	}
	return false
}

func (e TerrainType) String() string {
	return string(e)
}

func (e *TerrainType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerrainType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TerrainType", str)
	}
	return nil
}

func (e TerrainType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Theme string

const (
	ThemeDefault Theme = "DEFAULT"
	ThemeLight   Theme = "LIGHT"
	ThemeDark    Theme = "DARK"
)

var AllTheme = []Theme{
	ThemeDefault,
	ThemeLight,
	ThemeDark,
}

func (e Theme) IsValid() bool {
	switch e {
	case ThemeDefault, ThemeLight, ThemeDark:
		return true
	}
	return false
}

func (e Theme) String() string {
	return string(e)
}

func (e *Theme) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Theme(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Theme", str)
	}
	return nil
}

func (e Theme) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TileType string

const (
	TileTypeDefault             TileType = "DEFAULT"
	TileTypeLabelled            TileType = "LABELLED"
	TileTypeRoadMap             TileType = "ROAD_MAP"
	TileTypeOpenStreetMap       TileType = "OPEN_STREET_MAP"
	TileTypeEsriTopography      TileType = "ESRI_TOPOGRAPHY"
	TileTypeEarthAtNight        TileType = "EARTH_AT_NIGHT"
	TileTypeJapanGsiStandardMap TileType = "JAPAN_GSI_STANDARD_MAP"
	TileTypeURL                 TileType = "URL"
)

var AllTileType = []TileType{
	TileTypeDefault,
	TileTypeLabelled,
	TileTypeRoadMap,
	TileTypeOpenStreetMap,
	TileTypeEsriTopography,
	TileTypeEarthAtNight,
	TileTypeJapanGsiStandardMap,
	TileTypeURL,
}

func (e TileType) IsValid() bool {
	switch e {
	case TileTypeDefault, TileTypeLabelled, TileTypeRoadMap, TileTypeOpenStreetMap, TileTypeEsriTopography, TileTypeEarthAtNight, TileTypeJapanGsiStandardMap, TileTypeURL:
		return true
	}
	return false
}

func (e TileType) String() string {
	return string(e)
}

func (e *TileType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TileType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TileType", str)
	}
	return nil
}

func (e TileType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimeOperator string

const (
	TimeOperatorBefore      TimeOperator = "BEFORE"
	TimeOperatorAfter       TimeOperator = "AFTER"
	TimeOperatorBeforeOrOn  TimeOperator = "BEFORE_OR_ON"
	TimeOperatorAfterOrOn   TimeOperator = "AFTER_OR_ON"
	TimeOperatorOfThisWeek  TimeOperator = "OF_THIS_WEEK"
	TimeOperatorOfThisMonth TimeOperator = "OF_THIS_MONTH"
	TimeOperatorOfThisYear  TimeOperator = "OF_THIS_YEAR"
)

var AllTimeOperator = []TimeOperator{
	TimeOperatorBefore,
	TimeOperatorAfter,
	TimeOperatorBeforeOrOn,
	TimeOperatorAfterOrOn,
	TimeOperatorOfThisWeek,
	TimeOperatorOfThisMonth,
	TimeOperatorOfThisYear,
}

func (e TimeOperator) IsValid() bool {
	switch e {
	case TimeOperatorBefore, TimeOperatorAfter, TimeOperatorBeforeOrOn, TimeOperatorAfterOrOn, TimeOperatorOfThisWeek, TimeOperatorOfThisMonth, TimeOperatorOfThisYear:
		return true
	}
	return false
}

func (e TimeOperator) String() string {
	return string(e)
}

func (e *TimeOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeOperator", str)
	}
	return nil
}

func (e TimeOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
